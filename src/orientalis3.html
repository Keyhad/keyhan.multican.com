<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Persian Girih Watch - Connected</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rakkas&display=swap" rel="stylesheet">

    <style>
        :root {
            /* PALETTE: Isfahan / Haft Rang */
            --bg-body: #010205; 
            
            /* Dome Gradient */
            --dial-gradient-inner: #1a237e; 
            --dial-gradient-mid: #0d1333;   
            --dial-gradient-outer: #000000; 
            
            /* Hands/Cursors */
            --hour-active: #ffc107;    
            --minute-active: #26c6da;  
            --second-active: #ff6f00;  
            
            /* Grid Lines */
            --line-color: #c5a059;     
            --line-opacity: 0.4;
            
            /* Inactive slots backlight */
            --light-inactive: rgba(38, 198, 218, 0.03); 
            
            /* The specific color requested (3 o'clock border) */
            --cardinal-gold: #ffe082;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-body);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .watch-container {
            position: relative;
            width: 90vmin;
            height: 90vmin;
            max-width: 600px;
            max-height: 600px;
            border-radius: 50%;
            box-shadow: 
                0 0 0 2px #1a1a1a,
                0 0 0 8px #050a14, 
                0 20px 50px rgba(0,0,0,1),
                inset 0 0 80px rgba(0,0,0,1);
            background: #000;
            overflow: hidden;
        }

        svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg); 
        }

        #dial-cover {
            fill: url(#mosque-vignette);
            mask: url(#dial-holes-mask); 
        }

        .shape {
            fill: none; 
            stroke: var(--line-color);
            stroke-width: 0.5px;
            stroke-linejoin: round;
            stroke-linecap: round;
            opacity: var(--line-opacity);
        }

        .hour-shape { 
            stroke-width: 0.8px; 
            stroke: url(#ceramic-glaze); 
            fill: url(#hour-lens-grad);   
            filter: url(#rim-shadow);     
            opacity: 1;
        }

        /* The 3, 6, 9, 12 markers use this color */
        .hour-cardinal { 
            stroke-width: 1.2px; 
            opacity: 1; 
            stroke: var(--cardinal-gold); 
        }
        
        .minute-slot-outline { stroke: #3949ab; opacity: 0.5; } 
        .landmark { stroke: #4dd0e1; stroke-width: 0.8px; opacity: 0.8; } 
        .backlight-shape { stroke: none; fill: var(--light-inactive); }

        .cursor-group { transform-origin: 0px 0px; }

        .hour-cursor-shape {
            fill: var(--hour-active);
            filter: drop-shadow(0 0 5px var(--hour-active)) drop-shadow(0 0 15px var(--hour-active));
        }

        .minute-cursor-shape {
            fill: var(--minute-active);
            filter: drop-shadow(0 0 4px var(--minute-active)) drop-shadow(0 0 10px var(--minute-active));
        }

        .second-cursor-shape {
            fill: var(--second-active); 
            stroke: none;
            filter: drop-shadow(0 0 3px var(--second-active));
            mix-blend-mode: screen;
        }

        /* --- CALLIGRAPHY STYLING --- */
        .numeral-text {
            fill: url(#aged-gold-text); 
            font-family: 'Rakkas', serif; 
            font-weight: 400;
            font-size: 20px; 
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            stroke: #000033; 
            stroke-width: 0.8px;
            paint-order: stroke fill; 
            filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.8));
        }
        
        .metal-texture-fill {
            fill: url(#persian-dome-ceramic); 
            pointer-events: none;
        }

        .star-outline {
            fill: none;
            stroke: #c5a059; 
            stroke-width: 0.5px;
            filter: url(#gear-shadow);
        }

        .center-bolt {
            fill: url(#bolt-head);
            stroke: #8a6e3e; 
            stroke-width: 1px;
        }

        .needle-hand {
            fill: var(--cardinal-gold); 
            stroke: #bcaaa4; 
            stroke-width: 0.2px; 
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.8));
            transform-origin: 0 0; 
        }

        /* Connector Lines Style */
        .connector-line {
            fill: none;
            stroke: url(#connector-grad); /* Gradient stroke */
            stroke-linecap: butt; /* Butt needed so it touches exactly without rounding over */
        }

    </style>
</head>
<body>

<div class="watch-container">
    <svg viewBox="-100 -100 200 200" id="watchFace">
        <defs>
            <radialGradient id="mosque-vignette" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
                <stop offset="0%" style="stop-color:var(--dial-gradient-inner); stop-opacity:1" />
                <stop offset="60%" style="stop-color:var(--dial-gradient-mid); stop-opacity:1" />
                <stop offset="100%" style="stop-color:var(--dial-gradient-outer); stop-opacity:1" />
            </radialGradient>
            
            <radialGradient id="hour-lens-grad" cx="30%" cy="30%" r="80%" fx="30%" fy="30%">
                <stop offset="0%" style="stop-color:rgba(255,255,255,0.15); stop-opacity:1" />
                <stop offset="100%" style="stop-color:rgba(0,5,15,0.6); stop-opacity:1" />
            </radialGradient>

            <linearGradient id="ceramic-glaze" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#4dd0e1; stop-opacity:1" /> 
                <stop offset="50%" style="stop-color:#1a237e; stop-opacity:1" /> 
                <stop offset="100%" style="stop-color:#ffd700; stop-opacity:1" /> 
            </linearGradient>

            <radialGradient id="persian-dome-ceramic" cx="30%" cy="30%" r="80%" fx="25%" fy="25%">
                <stop offset="0%" stop-color="#80deea" /> 
                <stop offset="40%" stop-color="#0097a7" /> 
                <stop offset="80%" stop-color="#006064" /> 
                <stop offset="100%" stop-color="#000" /> 
            </radialGradient>

            <linearGradient id="aged-gold-text" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stop-color="#fff9c4" />
                <stop offset="50%" stop-color="#ffca28" />
                <stop offset="100%" stop-color="#ff6f00" />
            </linearGradient>

            <radialGradient id="bolt-head" cx="50%" cy="50%" r="50%" fx="30%" fy="30%">
                <stop offset="0%" stop-color="#fff" />
                <stop offset="40%" stop-color="#fbc02d" />
                <stop offset="100%" stop-color="#5d4037" />
            </radialGradient>

            <!-- 
                Gradient for the connector lines.
                It runs horizontally (which we will rotate per line via gradientUnits or just apply generally).
                However, since lines are radial, a linear gradient along the line works best.
                Since SVG strokes don't support gradients along path easily without complex setup,
                we will use userSpaceOnUse for the gradient to map it radially, OR simply use a linear gradient
                that assumes the line goes from center outward.
            -->
            <linearGradient id="connector-grad" x1="0%" y1="0%" x2="100%" y2="0%">
                <!-- Start: Star color/thickness simulation (Color #c5a059) -->
                <stop offset="0%" stop-color="#c5a059" />
                <!-- End: Cardinal Diamond color (Color #ffe082) -->
                <stop offset="100%" stop-color="#ffe082" />
            </linearGradient>

            <filter id="rim-shadow" x="-50%" y="-50%" width="200%" height="200%">
                <feDropShadow dx="0.5" dy="1" stdDeviation="1" flood-color="#000" flood-opacity="0.8"/>
            </filter>

            <filter id="gear-shadow" x="-50%" y="-50%" width="200%" height="200%">
                <feDropShadow dx="0" dy="2" stdDeviation="2" flood-color="#000" flood-opacity="0.9"/>
            </filter>

            <mask id="dial-holes-mask">
                <rect x="-150" y="-150" width="300" height="300" fill="white" />
                <g id="mask-holes-group" fill="black"></g>
            </mask>

            <path id="star-geom-def" />
            
            <path id="needle-geom-def" d="M -2 0 Q 8 1.7 16 0 Q 8 -1.7 -2 0 Z" />

            <mask id="static-star-mask">
                <rect x="-50" y="-50" width="100" height="100" fill="black" />
                <use href="#star-geom-def" fill="white" />
            </mask>
        </defs>

        <!-- LAYER 1: Background Grid -->
        <g id="static-grid-group"></g>

        <!-- LAYER 2: Cursors (Lights) -->
        <g id="hour-cursor-group" class="cursor-group"></g>
        <g id="minute-cursor-group" class="cursor-group"></g>
        <g id="second-cursor-group" class="cursor-group"></g>

        <!-- LAYER 3: Numerals (Text) -->
        <g id="numerals-group"></g>

        <!-- LAYER 4: Dial Cover -->
        <circle id="dial-cover" cx="0" cy="0" r="100"></circle>

        <!-- LAYER 4.5: Connectors (New Layer) -->
        <g id="connector-group"></g>

        <!-- LAYER 5: Rings -->
        <g id="hour-ring"></g>
        <g id="minute-ring-outlines"></g>
        
        <!-- LAYER 6: The Static Center Star -->
        <rect x="-30" y="-30" width="60" height="60" 
              class="metal-texture-fill" 
              mask="url(#static-star-mask)" />
        
        <use href="#star-geom-def" class="star-outline" />

        <!-- LAYER 7: The Rotating Needle -->
        <g id="needle-rotator">
            <use href="#needle-geom-def" class="needle-hand" />
        </g>

        <!-- Center Bolt (Static, on top) -->
        <circle cx="0" cy="0" r="4" class="center-bolt" />

    </svg>
</div>

<script>
    const maskHolesGroup = document.getElementById('mask-holes-group');
    const staticGridGroup = document.getElementById('static-grid-group');
    const numeralsGroup = document.getElementById('numerals-group');
    
    const hourRingGroup = document.getElementById('hour-ring');
    const minuteOutlineGroup = document.getElementById('minute-ring-outlines');
    const connectorGroup = document.getElementById('connector-group');
    
    const starGeomDef = document.getElementById('star-geom-def');
    const needleRotator = document.getElementById('needle-rotator');

    const secondCursorGroup = document.getElementById('second-cursor-group');
    const minuteCursorGroup = document.getElementById('minute-cursor-group');
    const hourCursorGroup = document.getElementById('hour-cursor-group');

    const OUTER_RING_CONFIG = { r1: 70, r2: 82, r3: 94, widthAngle: 2.2, roundness: 0.2 };
    const HOUR_RING_CONFIG = { r1: 25, r2: 48, r3: 65, angleSpread: 12, roundness: 0.15 };
    
    // Star Config (Must match defineCenterStar logic)
    const STAR_CONFIG = { outerRadius: 18, innerRadius: 8 };

    const CARDINAL_NUMERALS = {
        0: "١٢", 3: "٣", 6: "٦", 9: "٩"
    };

    function createPath(d, className, id) {
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", d);
        if (className) path.setAttribute("class", className);
        if (id) path.setAttribute("id", id);
        return path;
    }

    function createText(text, x, y, className) {
        const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
        t.setAttribute("x", x);
        t.setAttribute("y", y);
        t.textContent = text;
        if (className) t.setAttribute("class", className);
        t.setAttribute("transform", `rotate(90, ${x}, ${y}) translate(0, 1)`);
        return t;
    }

    function polarToCartesian(radius, angleInDegrees) {
        const angleInRadians = (angleInDegrees) * Math.PI / 180.0;
        return {
            x: (radius * Math.cos(angleInRadians)),
            y: (radius * Math.sin(angleInRadians))
        };
    }

    function createRoundedDiamondPath(p1, p2, p3, p4, roundness) {
        const lerp = (a, b, t) => ({ x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t });
        const p1_a = lerp(p1, p2, roundness);
        const p2_b = lerp(p2, p1, roundness);
        const p2_a = lerp(p2, p3, roundness);
        const p3_b = lerp(p3, p2, roundness);
        const p3_a = lerp(p3, p4, roundness);
        const p4_b = lerp(p4, p3, roundness);
        const p4_a = lerp(p4, p1, roundness);
        const p1_b = lerp(p1, p4, roundness);

        return `M ${p1_a.x} ${p1_a.y} 
                L ${p2_b.x} ${p2_b.y} Q ${p2.x} ${p2.y} ${p2_a.x} ${p2_a.y}
                L ${p3_b.x} ${p3_b.y} Q ${p3.x} ${p3.y} ${p3_a.x} ${p3_a.y}
                L ${p4_b.x} ${p4_b.y} Q ${p4.x} ${p4.y} ${p4_a.x} ${p4_a.y}
                L ${p1_b.x} ${p1_b.y} Q ${p1.x} ${p1.y} ${p1_a.x} ${p1_a.y} Z`;
    }

    function defineCenterStar() {
        const points = 12;
        const outerRadius = STAR_CONFIG.outerRadius;
        const innerRadius = STAR_CONFIG.innerRadius;
        const roundness = 0.35; 

        const vertices = [];
        for (let i = 0; i < points * 2; i++) {
            let r = (i % 2 === 0) ? outerRadius : innerRadius;
            let angle = i * (360 / (points * 2));
            vertices.push(polarToCartesian(r, angle));
        }

        const lerp = (p1, p2, t) => ({ x: p1.x + (p2.x - p1.x) * t, y: p1.y + (p2.y - p1.y) * t });

        let d = "";
        const len = vertices.length;
        const startPoint = lerp(vertices[len - 1], vertices[0], 0.5);
        d += `M ${startPoint.x} ${startPoint.y} `;
        for (let i = 0; i < len; i++) {
            const current = vertices[i];
            const next = vertices[(i + 1) % len];
            const prev = vertices[(i - 1 + len) % len];
            const pEndCurve = lerp(current, next, roundness);
            const pStartCurve = lerp(prev, current, 1 - roundness);
            d += `L ${pStartCurve.x} ${pStartCurve.y} `;
            d += `Q ${current.x} ${current.y} ${pEndCurve.x} ${pEndCurve.y} `;
        }
        d += "Z "; 
        starGeomDef.setAttribute("d", d);
    }

    function getHourPathData(angle) {
        const r1 = HOUR_RING_CONFIG.r1; 
        const r2 = HOUR_RING_CONFIG.r2; 
        const r3 = HOUR_RING_CONFIG.r3; 
        const p1 = polarToCartesian(r1, angle); 
        const p2 = polarToCartesian(r2, angle + HOUR_RING_CONFIG.angleSpread); 
        const p3 = polarToCartesian(r3, angle); 
        const p4 = polarToCartesian(r2, angle - HOUR_RING_CONFIG.angleSpread); 
        return createRoundedDiamondPath(p1, p2, p3, p4, HOUR_RING_CONFIG.roundness);
    }

    function getMinutePathData(angle) {
        const p1 = polarToCartesian(OUTER_RING_CONFIG.r1, angle);
        const p2 = polarToCartesian(OUTER_RING_CONFIG.r2, angle + OUTER_RING_CONFIG.widthAngle);
        const p3 = polarToCartesian(OUTER_RING_CONFIG.r3, angle);
        const p4 = polarToCartesian(OUTER_RING_CONFIG.r2, angle - OUTER_RING_CONFIG.widthAngle);
        return createRoundedDiamondPath(p1, p2, p3, p4, OUTER_RING_CONFIG.roundness);
    }

    function drawConnectors() {
        // We want to connect the star outer tips to the hour diamond inner tips at 0, 90, 180, 270
        const cardinals = [0, 90, 180, 270];
        
        cardinals.forEach(angle => {
            // 1. Calculate Start Point (Star Tip)
            // The star has 12 points. 360/12 = 30 deg per point.
            // The points are at 0, 30, 60... so they align perfectly with cardinals.
            const startP = polarToCartesian(STAR_CONFIG.outerRadius, angle);
            
            // 2. Calculate End Point (Inner tip of Hour Diamond)
            const endP = polarToCartesian(HOUR_RING_CONFIG.r1, angle);

            // 3. Create Line
            // We use a path instead of <line> to control stroke width via vector-effect if needed, 
            // but here we need a trapezoid shape to handle variable thickness.
            
            // Thickness Start: 0.5px (Star border)
            // Thickness End: 1.2px (Cardinal Diamond border)
            
            // Calculate perpendicular vector for thickness
            const angleRad = angle * Math.PI / 180;
            const perpAngle = angleRad + Math.PI / 2;
            
            const startHalfWidth = 0.5 / 2;
            const endHalfWidth = 1.2 / 2;
            
            const sx = Math.cos(perpAngle);
            const sy = Math.sin(perpAngle);
            
            // 4 corners of the connector trapezoid
            const p1 = { x: startP.x + sx * startHalfWidth, y: startP.y + sy * startHalfWidth };
            const p2 = { x: endP.x + sx * endHalfWidth, y: endP.y + sy * endHalfWidth };
            const p3 = { x: endP.x - sx * endHalfWidth, y: endP.y - sy * endHalfWidth };
            const p4 = { x: startP.x - sx * startHalfWidth, y: startP.y - sy * startHalfWidth };
            
            const d = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y} L ${p3.x} ${p3.y} L ${p4.x} ${p4.y} Z`;
            
            const path = createPath(d, "connector-line");
            
            // We need to rotate the gradient for each line so it flows from start to end
            // Or simpler: define a gradient in userSpaceOnUse for each, OR use a single gradient 
            // but map the points carefully. 
            // The easiest way for 4 cardinal directions with a linear gradient is to rotate the gradient 
            // inside the element using a pattern or just use the 'stroke' property with a gradient 
            // but since we are drawing a filled trapezoid (to handle variable width), we use fill.
            
            path.style.fill = "url(#connector-grad)";
            path.style.stroke = "none";
            
            // For the gradient to work correctly on rotated shapes, we need to rotate the gradient vector
            // or rotate the shape. Since the points are calculated in absolute space, the gradient 
            // needs to be absolute or we rely on the fact that linearGradient default is Left-to-Right.
            // Let's set the gradientTransform on the path to align with the angle.
            
            // However, SVG gradients are tricky on paths. 
            // Strategy: Create a unique gradient ID for each cardinal or use gradientTransform.
            const gradId = `conn-grad-${angle}`;
            const grad = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
            grad.setAttribute("id", gradId);
            grad.setAttribute("gradientUnits", "userSpaceOnUse");
            grad.setAttribute("x1", startP.x);
            grad.setAttribute("y1", startP.y);
            grad.setAttribute("x2", endP.x);
            grad.setAttribute("y2", endP.y);
            
            const stop1 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
            stop1.setAttribute("offset", "0%");
            stop1.setAttribute("stop-color", "#c5a059"); // Star color
            
            const stop2 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
            stop2.setAttribute("offset", "100%");
            stop2.setAttribute("stop-color", "#ffe082"); // Diamond color
            
            grad.appendChild(stop1);
            grad.appendChild(stop2);
            
            document.querySelector("defs").appendChild(grad);
            path.style.fill = `url(#${gradId})`;

            connectorGroup.appendChild(path);
        });
    }

    function drawStaticGrid() {
        for (let i = 0; i < 12; i++) {
            const angle = i * 30; 
            let d = getHourPathData(angle);
            maskHolesGroup.appendChild(createPath(d, null));
            let className = "shape hour-shape";
            if (i % 3 === 0) className += " hour-cardinal";
            hourRingGroup.appendChild(createPath(d, className));
            staticGridGroup.appendChild(createPath(d, "backlight-shape"));

            if (CARDINAL_NUMERALS[i] !== undefined) {
                const center = polarToCartesian(HOUR_RING_CONFIG.r2, angle);
                const textEl = createText(CARDINAL_NUMERALS[i], center.x, center.y, "numeral-text");
                numeralsGroup.appendChild(textEl);
            }
        }

        for (let i = 0; i < 60; i++) {
            const angle = i * 6;
            let d = getMinutePathData(angle);
            maskHolesGroup.appendChild(createPath(d, null));
            let className = "shape minute-slot-outline";
            if (i % 5 === 0) className += " landmark";
            minuteOutlineGroup.appendChild(createPath(d, className));
            staticGridGroup.appendChild(createPath(d, "backlight-shape"));
        }
    }

    function createCursors() {
        const hourD = getHourPathData(0);
        hourCursorGroup.appendChild(createPath(hourD, "hour-cursor-shape"));

        const minD = getMinutePathData(0);
        minuteCursorGroup.appendChild(createPath(minD, "minute-cursor-shape"));

        const angle = 0;
        const expand = 2; 
        const p1 = polarToCartesian(OUTER_RING_CONFIG.r1 - expand, angle);
        const p2 = polarToCartesian(OUTER_RING_CONFIG.r2, angle + OUTER_RING_CONFIG.widthAngle + 1.5);
        const p3 = polarToCartesian(OUTER_RING_CONFIG.r3 + expand, angle);
        const p4 = polarToCartesian(OUTER_RING_CONFIG.r2, angle - OUTER_RING_CONFIG.widthAngle - 1.5);
        let secD = createRoundedDiamondPath(p1, p2, p3, p4, OUTER_RING_CONFIG.roundness);
        secondCursorGroup.appendChild(createPath(secD, "second-cursor-shape"));
    }

    defineCenterStar();
    drawStaticGrid();
    drawConnectors(); // New function call
    createCursors();

    function updateClock() {
        const now = new Date();
        const hours = now.getHours();
        const minutes = now.getMinutes();
        const seconds = now.getSeconds();
        const ms = now.getMilliseconds();

        const secAngle = (seconds + ms / 1000) * 6;
        const minAngle = (minutes * 6) + (seconds / 60 * 6) + (ms / 60000 * 6);
        const hourAngle = ((hours % 12) * 30) + (minutes / 60 * 30);

        secondCursorGroup.style.transform = `rotate(${secAngle}deg)`;
        minuteCursorGroup.style.transform = `rotate(${minAngle}deg)`;
        hourCursorGroup.style.transform = `rotate(${hourAngle}deg)`;
        
        needleRotator.style.transform = `rotate(${secAngle}deg)`;
        
        requestAnimationFrame(updateClock);
    }
    updateClock();
</script>
</body>
</html>